# Gigahorse Benchmarks — YulTracer Analysis

This directory contains benchmarks originally sourced from the [gigahorse-benchmarks](https://github.com/nevillegrech/gigahorse-benchmarks), along with a collection of processed variants adapted for analysis with **YulTracer** (abbreviated **yult**), our tool for analysing smart contracts compiled into EVM-flavoured Yul.

---

## Quick Start

This directory contains a YulTracer-compatible subset of the gigahorse-benchmarks. Each example:

* Starts from vulnerable source in the gigahorse-benchmarks
* Is transformed to be Solidity 0.8.x compatible (while preserving semantics)
* Is compiled to Yul
* Is analysed using YulTracer

All necessary **preprocessing of source files has already been performed**. You can immediately run YulTracer on any processed example by entering its directory and running:

```bash
make run
```

To run YulTracer on **all examples**, use:  

```
bash run-reentrancy-tests.sh
```

This will print a summary listing every directory, whether the assertion violation was found, and the time taken to find the error. To see the output of YulTracer and record logs, use verbose mode:

```
bash run-reentrancy-tests.sh -v
```

This will create a log directory (`reentrancy-logs-YYYYmmdd-HHMMSS`) and redirect all the output of the tool to the terminal and to log files in the log directory.

**Note:** To run the commands above, the environment must have Python installed with the `Crypto` library (typically provided by `pycryptodome`). You can install it via:

```bash
pip install pycryptodome
```

On Linux, you may have to set up a virtual environment to avoid clashing with the system-wide Python environment. e.g. on Ubuntu this can be done using `venv`.

---

## Directory Structure

```
gigahorse-benchmarks/
├── original-vulnerable-sources/
└── yult-processed-vulnerable-sources/
```

### `original-vulnerable-sources/`

This directory contains the **109 original Solidity source files** from the gigahorse-benchmarks. Each file is an unmodified Solidity source for an example demonstrating a vulnerability, e.g., `reentrancy_0x23a91059fdc9579a9fbd0edc5f2ea0bfdb70deb4.sol`.

### `yult-processed-vulnerable-sources/`

This directory contains processed versions of selected examples from the original set, **adapted for analysis with YulTracer**. Currently, only **reentrancy-related examples** are included.

Each entry in this directory corresponds to a specific benchmark and is named after the original Solidity file, but without the `.sol` extension. For example, for the file `original-vulnerable-sources/reentrancy_etherbank.sol` we would have a corresponding directory:

```
yult-processed-vulnerable-sources/
└── reentrancy_etherbank/
```

Each such directory contains the following:

#### `abi/`

Contains the ABI for the main contract (entry point) in the processed source. For instance:

* `EtherBank_pruned.json`: ABI of `EtherBank.sol`. The `_pruned` suffix refers to the possibility of ABI pruning by preprocessing scripts; currently, these are unpruned and complete.

#### `scripts/`

Contains the scripts used to transform the original benchmark into a form suitable for analysis. Notably:

* `transform_solidity_040_to_080.py`: Converts legacy Solidity versions (e.g., 0.4.x) to 0.8.x-compatible syntax and constructs. Each example may have its own such script specifically tailored to handle it. Further manual inspection may have been performed to ensure compatibility; where necessary, manual modifications will have a corresponding comment in the processed source file indicating what was done.

#### `src/`

Contains the solidity sources for the example in the current directory:
* `<original>.sol`: The original file, copied from `original-vulnerable-sources/`
* `<EntryPoint>.sol`: A transformed Solidity file generated by scripts and possibly by further manual inspection, containing the entry-point contract.

For example:

```
src/
├── reentrancy_etherbank.sol        # original source: contains entry-point contract `EtherBank`
└── EtherBank.sol                   # transformed source: named after entry-point contract
```

The filename must match the main contract’s name (`EtherBank` in this case).

#### `yul/`

Generated output after building the example with the included `Makefile`.

This contains:

* The `.yul` files generated by `solc`
* JSON artefacts generated during compilation
* Post-processed the entry-point Yul with YulTracer-specific passes applied:

    * **Linking**: Resolving any linker symbols
    * ****yult** activation**: Enables internal YulTracer functions
    * ****Yult** object rewriting**: Normalizes internal objects
    * **Unchecked arithmetic disabling**: To preserve semantics from pre-0.8 Solidity
    * **ABI object name fixing**: Ensures the object names in the ABI (e.g., `EtherBank_*`) match the compiled Yul output

#### `Makefile`

Each directory has a `Makefile` that controls the full build and analysis pipeline. e.g.:

Key parameters:

```make
ENTRY_OBJECT_NAME := EtherBank
```

This defines the contract name and is used to:

* Select the entry-point contract to analyse (`EtherBank` in this case)
* Name the output `.sol` file to be compiled (`EtherBank.sol` in this case)

```make
CORE_ARGS ?= \
    -g \
    -b 2 \
    -o-call-stack 2 \
    -deploy-value 0 \
    -o-uint-domain "1000000000000000001" \
    -o-default-spending 1000000000000000001 \
    -max-time 1
```

These are the flags/parameters passed to `yult`. A typical direct invocation of `yult` may look like:

```bash
dune exec -- yult -i <input.yul> $(CORE_ARGS)
```
Common parameters used in these analyses:

* `-o-default-spending` and `-o-uint-domain` (opponent spending and opponent `uint` arguments): 

    - 1 (1 WEI)
    - 1000000000000000000 (1 ETH)
    - 1000000000000000001 (>1 ETH)
    - 2000000000000000000 (2 ETH)
    - 2000000000000000001 (>2 ETH)

* `-o-call-stack` (depth at which o-calls can occur): 2, 3, 4
* `-no-wait` (if no timestamps are used in the contract, i.e. time isn't important)
* `-max-time` (maximum number of cumulative days the opponent can wait): 1 (unless set, opponent will wait 7 days by default, so setting `max-time` to 1 will have the opponent wait once, since 7>1 after one wait)
* `-o-address-count` (number of opponent addresses participating in the analysis): 2 (if two opponent addresses are needed for the bug)

## Running a Benchmark with YulTracer

To run the analysis, within one of the benchmark directories, use:

```bash
make run
```

This will:

1. Compile the contract with `solc`
2. Generate and prepare the ABI
3. Run all postprocessing scripts
4. Launch YulTracer on the entry-point contract

To run YulTracer on **all examples**, we provide a script:  

```
bash run-reentrancy-tests.sh
```

This will print a summary listing every directory, whether the assertion violation was found, and the time taken to find the error. To see the output of YulTracer and record logs, use verbose mode:

```
bash run-reentrancy-tests.sh -v
```

This will create a log directory (`reentrancy-logs-YYYYmmdd-HHMMSS`) and redirect all the output of the tool to the terminal and to log files in the log directory.

## Notes

The following benchmarks had to be modified:

- `reentrancy_modifier_reentrancy`: Original was safe in 0.5.0+. Pure annotation removed because it now compiles to `STATICCALL`, which does not allow state changes.
- `reentrancy_reentrancy_cross_function`: Original was safe without a `deposit` method. Added `deposit` method to make reentrant withdraw possible.
- `reentrancy_reentrancy_insecure`: Original was safe without a `deposit` method. Added `deposit` method to make reentrant withdraw possible.
- `reentrancy_modifier_reentrancy`: The benchmark does not send any ETH, so a YulTracer assertion hook was added to capture the reentrancy error on the token balance. 